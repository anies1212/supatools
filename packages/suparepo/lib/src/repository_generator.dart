import 'package:recase/recase.dart';
import 'package:supabase_schema_core/supabase_schema_core.dart';
import 'config_loader.dart';

/// Generates repository code from table information
class RepositoryGenerator {
  /// Configuration for generation
  SuparepoConfig? _config;

  /// Sets the configuration
  void setConfig(SuparepoConfig config) {
    _config = config;
  }

  /// Gets the class name for a table's model
  String getModelClassName(String tableName) {
    return ReCase(tableName).pascalCase;
  }

  /// Gets the repository class name for a table
  String getRepositoryClassName(String tableName) {
    return '${ReCase(tableName).pascalCase}Repository';
  }

  /// Gets the file name for a repository
  String getFileName(String tableName) {
    return '${ReCase(tableName).snakeCase}_repository.dart';
  }

  /// Generates a repository file content for a single table
  String generateRepository(TableInfo table) {
    final modelClassName = getModelClassName(table.name);
    final repoClassName = getRepositoryClassName(table.name);
    final tableName = table.name;

    // Find primary key column
    final primaryKey = table.columns.firstWhere(
      (c) => c.isPrimaryKey,
      orElse: () => table.columns.firstWhere(
        (c) => c.name == 'id',
        orElse: () => table.columns.first,
      ),
    );
    final pkName = primaryKey.name;
    final pkDartType = TypeMapper.mapType(primaryKey.dataType);

    final buffer = StringBuffer();

    // Header
    buffer.writeln('// GENERATED CODE - DO NOT MODIFY BY HAND');
    buffer.writeln('// Generated by suparepo');
    buffer.writeln();

    // Imports
    buffer.writeln("import 'package:supabase_flutter/supabase_flutter.dart';");
    if (_config?.modelImportPath != null) {
      buffer.writeln("import '${_config!.modelImportPath}';");
    }
    buffer.writeln();

    // Class definition
    buffer.writeln('/// Repository for $tableName table');
    buffer.writeln('class $repoClassName {');
    buffer.writeln('  final SupabaseClient _client;');
    buffer.writeln();
    buffer.writeln('  $repoClassName(this._client);');
    buffer.writeln();

    // Table name getter
    buffer.writeln("  String get tableName => '$tableName';");
    buffer.writeln();

    // getAll method
    buffer.writeln('  /// Fetches all records from $tableName');
    if (_config?.modelImportPath != null) {
      buffer.writeln('  Future<List<$modelClassName>> getAll() async {');
      buffer.writeln(
          "    final response = await _client.from(tableName).select();");
      buffer.writeln(
          '    return response.map((e) => $modelClassName.fromJson(e)).toList();');
    } else {
      buffer.writeln('  Future<List<Map<String, dynamic>>> getAll() async {');
      buffer.writeln(
          "    final response = await _client.from(tableName).select();");
      buffer.writeln('    return response;');
    }
    buffer.writeln('  }');
    buffer.writeln();

    // getById method
    buffer.writeln('  /// Fetches a single record by $pkName');
    if (_config?.modelImportPath != null) {
      buffer.writeln(
          '  Future<$modelClassName?> getById($pkDartType $pkName) async {');
      buffer.writeln('    final response = await _client');
      buffer.writeln('        .from(tableName)');
      buffer.writeln('        .select()');
      buffer.writeln("        .eq('$pkName', $pkName)");
      buffer.writeln('        .maybeSingle();');
      buffer.writeln(
          '    return response != null ? $modelClassName.fromJson(response) : null;');
    } else {
      buffer.writeln(
          '  Future<Map<String, dynamic>?> getById($pkDartType $pkName) async {');
      buffer.writeln('    final response = await _client');
      buffer.writeln('        .from(tableName)');
      buffer.writeln('        .select()');
      buffer.writeln("        .eq('$pkName', $pkName)");
      buffer.writeln('        .maybeSingle();');
      buffer.writeln('    return response;');
    }
    buffer.writeln('  }');
    buffer.writeln();

    // create method
    buffer.writeln('  /// Creates a new record');
    if (_config?.modelImportPath != null) {
      buffer.writeln(
          '  Future<$modelClassName> create($modelClassName data) async {');
      buffer.writeln('    final response = await _client');
      buffer.writeln('        .from(tableName)');
      buffer.writeln('        .insert(data.toJson())');
      buffer.writeln('        .select()');
      buffer.writeln('        .single();');
      buffer.writeln('    return $modelClassName.fromJson(response);');
    } else {
      buffer.writeln(
          '  Future<Map<String, dynamic>> create(Map<String, dynamic> data) async {');
      buffer.writeln('    final response = await _client');
      buffer.writeln('        .from(tableName)');
      buffer.writeln('        .insert(data)');
      buffer.writeln('        .select()');
      buffer.writeln('        .single();');
      buffer.writeln('    return response;');
    }
    buffer.writeln('  }');
    buffer.writeln();

    // update method
    buffer.writeln('  /// Updates an existing record');
    if (_config?.modelImportPath != null) {
      buffer.writeln(
          '  Future<$modelClassName> update($pkDartType $pkName, $modelClassName data) async {');
      buffer.writeln('    final response = await _client');
      buffer.writeln('        .from(tableName)');
      buffer.writeln('        .update(data.toJson())');
      buffer.writeln("        .eq('$pkName', $pkName)");
      buffer.writeln('        .select()');
      buffer.writeln('        .single();');
      buffer.writeln('    return $modelClassName.fromJson(response);');
    } else {
      buffer.writeln(
          '  Future<Map<String, dynamic>> update($pkDartType $pkName, Map<String, dynamic> data) async {');
      buffer.writeln('    final response = await _client');
      buffer.writeln('        .from(tableName)');
      buffer.writeln('        .update(data)');
      buffer.writeln("        .eq('$pkName', $pkName)");
      buffer.writeln('        .select()');
      buffer.writeln('        .single();');
      buffer.writeln('    return response;');
    }
    buffer.writeln('  }');
    buffer.writeln();

    // delete method
    buffer.writeln('  /// Deletes a record by $pkName');
    buffer.writeln('  Future<void> delete($pkDartType $pkName) async {');
    buffer.writeln('    await _client');
    buffer.writeln('        .from(tableName)');
    buffer.writeln('        .delete()');
    buffer.writeln("        .eq('$pkName', $pkName);");
    buffer.writeln('  }');
    buffer.writeln();

    // count method
    buffer.writeln('  /// Gets the total count of records');
    buffer.writeln('  Future<int> count() async {');
    buffer.writeln('    final response = await _client');
    buffer.writeln('        .from(tableName)');
    buffer.writeln(
        "        .select('*', const FetchOptions(count: CountOption.exact, head: true));");
    buffer.writeln('    return response.count ?? 0;');
    buffer.writeln('  }');
    buffer.writeln();

    // paginate method
    buffer.writeln('  /// Fetches records with pagination');
    if (_config?.modelImportPath != null) {
      buffer.writeln(
          '  Future<List<$modelClassName>> paginate({int page = 1, int perPage = 20}) async {');
      buffer.writeln('    final from = (page - 1) * perPage;');
      buffer.writeln('    final to = from + perPage - 1;');
      buffer.writeln('    final response = await _client');
      buffer.writeln('        .from(tableName)');
      buffer.writeln('        .select()');
      buffer.writeln('        .range(from, to);');
      buffer.writeln(
          '    return response.map((e) => $modelClassName.fromJson(e)).toList();');
    } else {
      buffer.writeln(
          '  Future<List<Map<String, dynamic>>> paginate({int page = 1, int perPage = 20}) async {');
      buffer.writeln('    final from = (page - 1) * perPage;');
      buffer.writeln('    final to = from + perPage - 1;');
      buffer.writeln('    final response = await _client');
      buffer.writeln('        .from(tableName)');
      buffer.writeln('        .select()');
      buffer.writeln('        .range(from, to);');
      buffer.writeln('    return response;');
    }
    buffer.writeln('  }');

    // Generate relation methods for foreign keys
    for (final column in table.columns) {
      if (column.foreignKey != null) {
        final fk = column.foreignKey!;
        final relationName = _getRelationName(column.name);

        buffer.writeln();
        buffer.writeln(
            '  /// Fetches records with $relationName relation embedded');
        if (_config?.modelImportPath != null) {
          buffer.writeln(
              '  Future<List<$modelClassName>> getAllWith${ReCase(relationName).pascalCase}() async {');
          buffer.writeln('    final response = await _client');
          buffer.writeln('        .from(tableName)');
          buffer.writeln(
              "        .select('*, $relationName:${fk.referencedTable}(*)');");
          buffer.writeln(
              '    return response.map((e) => $modelClassName.fromJson(e)).toList();');
        } else {
          buffer.writeln(
              '  Future<List<Map<String, dynamic>>> getAllWith${ReCase(relationName).pascalCase}() async {');
          buffer.writeln('    final response = await _client');
          buffer.writeln('        .from(tableName)');
          buffer.writeln(
              "        .select('*, $relationName:${fk.referencedTable}(*)');");
          buffer.writeln('    return response;');
        }
        buffer.writeln('  }');
      }
    }

    buffer.writeln('}');

    return buffer.toString();
  }

  /// Gets the relation name from a foreign key column name
  String _getRelationName(String columnName) {
    if (columnName.endsWith('_id')) {
      return columnName.substring(0, columnName.length - 3);
    }
    return columnName;
  }

  /// Generates all repositories and returns a map of filename to content
  Map<String, String> generateAllRepositories(List<TableInfo> tables) {
    final result = <String, String>{};

    for (final table in tables) {
      final fileName = getFileName(table.name);
      result[fileName] = generateRepository(table);
    }

    // Generate barrel file if enabled
    if (_config?.generateBarrel == true) {
      result['repositories.dart'] = generateBarrelFile(tables);
    }

    return result;
  }

  /// Generates a barrel file that exports all repositories
  String generateBarrelFile(List<TableInfo> tables) {
    final buffer = StringBuffer();
    buffer.writeln('// GENERATED CODE - DO NOT MODIFY BY HAND');
    buffer.writeln('// Generated by suparepo');
    buffer.writeln();

    for (final table in tables) {
      final fileName = getFileName(table.name);
      buffer.writeln("export '$fileName';");
    }

    return buffer.toString();
  }
}
